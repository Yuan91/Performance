**iOS 图像显示原理与性能优化**

# 图像显示原理

iOS 中视图/图层和动画显示到屏幕上,大致有6个阶段,它们由CPU和GPU共同协作来完成.

## App进程

* **Layout** - 这个阶段的任务:创建UIView/CALayer,设置他们的属性(颜色,边框,背景颜色),添加到父视图等

* **Display** - 这个阶段任务:`layer.contents`的绘制,期间可能会触发`-drawRect:`,`-drawLayer:inContext:`,`-displayLayer`等方法

* **Prepare** - 这是`Core Animation`将动画数据提交到渲染服务的准备阶段.除此之外,也会做一些图片解码的工作

* **Commit** - 这个阶段`Core Animation`通过IPC进程间通信,将我们准备好的所有图层和动画属性提交到渲染服务进程.

在这四个步骤中,程序员能够控件的是前两个过程,后两个过程是由`Core Animation`控制的.当`Commit`完成之后,显示任务到达渲染进程,已经离开了我们的App.

## 渲染进程

当显示任务到渲染进程的,它会把上一步提交的图层和动画,反序列化成一个叫做**渲染树**的图层树.使用这个渲染树,渲染服务对每一帧图像做如下工作:

* 对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）

* 执行图层合成和纹理渲染,生成一个能够显示到屏幕上的像素数据.

这六个阶段,只有最后的渲染操作是在GPU中执行,其他操作都是在CPU中执行的

## 关于GPU中纹理的合成

### 像素及布局
屏幕上的像素是由红绿蓝三种颜色和透明度构成的.

像素有多种布局方式:

① ARGB布局,每个像素占用4个比特,分别用来存储A/R/G/B信息,透明度被存储在最前面,最终的红/蓝/绿的值都会预先被乘以alpha的值.它在内存中布局,如下:
```
  A   R   G   B   A   R   G   B   A   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
```
采用这种布局的图片,占用内存的计算:**图片宽 * 图片高 * 4**
如100 * 200像素的图片,在内存中占用的大小是:100 * 200 * 4比特

②另外一种xRGB,默认没有任何alpha值,这样每一个像素都会省下一个不用的字节,整体将会减少25%的空间.

### 纹理合成
>所谓纹理即是一堆被精心排列过的像素,渲染则是将数据数据生成图像的过程.所谓纹理渲染则是将保存在内存中的像素数据生成图像的过程.

CALayer有一个`backing store`用来存储绘制的位图,而这个位图也是由RGB数据构成.

所以我们可以认为,纹理对应一个`CALayer`的位图.

>每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的上方。对于屏幕上的 每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是纹理合成大概的意思

在理想情况下(两个纹理的像素对齐),我们将第二个纹理放在第一个纹理上,GPU会将第二个像素合并到第一个像素中.合并的公式如下:
```
R = S + D * ( 1 – Sa )

R:合并后像素
S:上面纹理颜色
D:下面纹理颜色
Sa:下面纹理的透明度
```
这里我们假设 S 为红色(RGB=1,0,0),D为蓝色(RGB=0,0,1),我们来看下下面两种情况.

①当两个纹理都不透明,即`Sa = 1`,那么`R = S`,即颜色完全由上层纹理决定,所以合并后的纹理是红色.正如我们预料的红色覆盖蓝色

②当上面颜色的透明度为0.5,即`Sa = 0.5`,此时 `S = (0.5,0,0)`.我们来计算一下合成后的颜色:
```

               0.5 0           0.5 
R= S+D*(1-Sa)= 0 + 0 *(1-0.5) = 0
               0   1           0.5
```
最终得到的RGB值为(0.5, 0, 0.5),是一个紫色.

这是在两个纹理的情况下,一个像素的合成.那么合成多个像素,多个图层,将会消耗更多的GPU资源.就是为什么我们鼓励开发减少视图层级的原因.

### opaque
当上层纹理是完全不透明的时候，目标像素就等于上层纹理.这可以省下 GPU 很大的工作量，这样只需简单的拷⻉上层纹理而不需要合成所有的像素值。但是没有方法能告诉 GPU 纹理上的像素是透明还是不透明的。只有当 你作为一名开发者知道你放什么到 CALayer 上了。这也是为什么 CALayer 有一个叫做 opaque 的属性了。如 果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷⻉，不需要考虑它下方的任何东⻄(因为都 被它遮挡住了)。这节省了 GPU 相当大的工作量。


## CPU与GPU的协作

![avatar](https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png)

CPU将计算好的数据提交到GPU,GPU负责将图像数据渲染成屏幕能够显示的像素数据,放到帧缓冲区中,视频控制器在VSync来临时,将缓存的数据放到显示器是显示
Vsync信号由硬件时钟产生,频率是1秒60次,即16.7ms一次.视频控制器按照这个频率从帧缓冲区中读取数据显示到屏幕上.


### 进程间通信
![avatar](https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_runloop.png)

硬件时钟的Vsync按照16.7ms的速度发送信号到系统的图形服务器,图像服务器收到信号后,通过IPC进程间通信通知我们的App.App 的 Runloop 在启动后会注册对应的 CFRunLoopSource(Source1) 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。

Core Animation也在主线程的 runloop 注册了 Observer,监听了`beforeWaiting`和`exit`两个状态.这个观察者的优先级是2000000,低于其他的观察者,当一个触摸事件/timer/dispatch事件,唤醒runloop后,runloop会优先处理唤醒事件,唤醒之后App可能会执行一些UI更新,比如动画/frame调整/透明度变化等,这些最终都会被CALayer捕获,并被`Core Animation`包装成一个`CATransaction`事务提交到一个中间状态,等到runloop处于空闲状态(`beforeWaiting`)或者即将推出(`exit`)的时候,关注该事件的 Observer 都会得到通知.这时 CA 注册的那个 Observer 就会在回调中,将这些操作提交GPU进行渲染.

# 影响性能因素的分析与解决

![avatar](https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png)

根据上面的分析,我们知道当一次Vsync信号来临时,CPU和GPU的操作应该完成,并且将结果提交到帧缓冲区中等待视频控制器读取.假如Vsync来临时,显示内容没有准备好,就会先显示上一帧的内容,也就形成了我们常说的卡顿掉帧的现象.

## 耗时操作分析

### CPU资源消耗
CPU资源消耗大致有这个几类:

* **视图创建** - UIView的创建,调整,销毁等都会消耗CPU资源,CALayer是一个相比UIView相对轻量的对象,但是使用CALayer代理UIView并不能显著的提升程序的性能,所以在性能优化一开始就想着使用CALayer代替UIView并不是一个明智的选项.

* **属性调整** - CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里,这是一个耗时操作.而UIView的大部分属性,如frame/bounds等都是通过CALayer映射而来,所以应该避免不必要的属性调整.

* **布局计算** - 在列表滑动的时候,会频繁触发布局的计算.

* **文本计算与绘制** - 宽高计算与绘制会占用很大一部分资源，并且不可避免

* **图像解码** - UIImage创建之后,等到被添加到UIImageView 上才会开始解码,默认在主线程执行,也是一个耗时操作.

* **视图绘制** - 视图的绘制,需要配置环境以及创建上下文

### GPU资源消耗

* **纹理渲染** - 所有需要显示到屏幕上的内容都要通过GPU来渲染,包括视图,文本,图像等

* **视图混合** - 当有视图混合的时候,GPU需要花费额外的资源去计算一个像素点需要颜色值

* **离屏渲染** - 这需要在当前缓冲区外在开辟一个缓冲区,且需要处理渲染上下文的切换


## 优化性能的措施

在性能检测中有一个指标叫做`Color Misaligned Images`,它表示视图的像素值转换为坐标的时候不是整数值.这个时候需要系统额外做一下像素裁剪.保证坐标是整数时减少了系统的裁剪操作,当然对性能有提升.但是可以预见的是,这个优化对于性能的提升是微乎其微的.

所以我们在做性能优化的时候,应该从最能提升性能,而操作起来比较简单的着手.

* **减少Storyboard/Xib使用** - Storyboard/Xib的创建是要比UIView的创建更消耗资源的,你应该避免它的使用

* **预排版** - 在列表滑动时,会频繁触发`cell`中子视图的布局计算,频繁访问视图的`frame/bounds`等属性,在类似朋友圈的界面中,性能消耗尤为明显.我们可以通过在异步线程中,提前计算好`cell`中各个控件的坐标以及`cellHeight`,来避免主线程压力和重复计算布局的性能消耗.

* **图片异步解码** - `UIImage`创建出来的时候并没有被解码,当它被添加到`UIImageView`时才会开始解码,而且这个解码是默认是在CPU中会消耗大量资源,所以可以使用异步解码技术.如果你使用的是`SDWebImage`来加载图片,那这个已经默认帮你处理好了.

* **异步绘制** - 对于`UIView/UILabel/UIImageView`等内容的显示,可以采用异步绘制的技术在`-displayLayer`方法中,将要显示的内容生成一个`bitmap`,最终在主线程中将结果赋值给`layer.contents`

* **减少视图层级** - 对于复杂的视图层级,GPU在计算每一个像素点颜色值的时候就会消耗更多的资源,另外计算图层帧率也会消耗一部分时间.对于这种情况,常见的解决方法是,尽量减少视图层级,有可能的话将内容绘制到一个视图上.

* **避免离屏渲染** - 视图`CALayer`的`shouldRasterize`,`mask`,`shadowXXX`,圆角(可能)等操作会触发离屏渲染,这个操作发生在GPU中.当触发离屏渲染的时候需要新开辟缓冲区和进行上下文的切换,是一个相当消耗GPU的操作.对于能够复用的离屏渲染结果,可以通过`shouldRasterize`将结果缓存,避免每次显示都要重新生成图层.当然最好还是避免产生离屏渲染

* **预加载** - iOS 10之后,系统对于`UITableView`和`UICollectionView`提供了预加载Api,如`- tableView: prefetchRowsAtIndexPaths:`,可以预处理一些耗时操作

* **opaque设置YES** - 当多个纹理重合的时候,如果上层纹理设置了不透明,那么GPU会直接取它的像素数据去显示,避免了像素合成的计算.


